# python-orrery-lesson
Educational Process covering the creation of an Orrery in python, and the underlying physics and code

## Contents

This tutorial will cover multiple topics, with the ultimate goal of producing a complete and customisable Orrery simulation in python.

We will cover:
1. Co-ordinates and Vectors
1. Python Structures and Iterators
1. Velocity & Acceleration
1. Differentiation
1. Newtonian Gravity
1. Vpython simulation


## Structure

This tutorial will take the form of a set of jupyter notebooks, these notebooks should be sufficient to guide a user through the process. Due to the nature of both physics and programming, it will be likely that further assistance will be needed, and to that end, I will include an assistance methodology and an FAQ in this tutorial.

## Assistance Methodology

There are two different sources of confusion in this tutorial: confusion about the physics concepts, or confusion about the python ones. They will require different but similar methods for resolving the problem.

First you need to break down where in the process you are having problems, and this will help provide you with the language framework to talk about your issue.

1. At the beginning of the process, you dont know where to start.
  This is a common problem with difficult concepts which you are new to, they are extra difficult to map onto other environments.
2. At the middle of the process, you dont know how to do something.
  This is another common problem, which mostly stems from an unfamiliarity with the implementation language. You know the concept, but you just don't know how to put it in place.
3. At the end of the process, your result is not what you expected.
  This one is pretty much common always, this is where you know what approach to take, and you know what tools you want to use, but the output is just not what you expected.


Problem 1 is one which will require the most assistance from someone else, and can be very specific to your problem. This will also hopefully be rare in this tutorial since the tasks are designed to give you the initial jump into the process. A likely helpful process for resolving this issue is to think about the numbers which are involved in a system you are trying to implement. In the situation where you are trying to simulate a situation to see what is happening to a certain component, or where you want to determine the outcome. formulating the problem mathematically will likely be of major help when trying to implement it in code.

Problem 2 is one which you will encounter frequently, but thankfully will not need as much special assistance for. Importantly, by understanding that you have a type 2 problem, much of the language you need to use to get assistance is pre-prepared, in the form of: "How to do {thing_you_want_to_do} in {language_you_want_to_do_it_in}?". Simply typing that phrase into a search engine of your choice will likely send you in the right direction. There is a high chance that there is a forum/community/issue/stackoverflow post which is relevant to your problem and will show you the framework to get it done.

Problem 3 can either be an unexpected, but functioning result, or an error. These problems are caused by the process you are implementing either doing something wrong, but succeeding, or failing trying to do something. The best way to tackle this issue is to break it down. Your process likely has a lot of moving parts, and you want to isolate them into progressively smaller chunks. This allows you to complete the first essential task of fixing errors, finding the problem. You will do this by assuming the correct output for a minimal example of each part of your process, then run each part of that process as if all the other parts were working. you will quickly identify which parts of your process are failing to live up to your expectations. you can then scale back up, running progressively larger and larger parts of the process, confirming they are correct, until you eventually have a full working system.

These three approaches can be used to set guidelines for how you should proceed with generating something new.
1. Understand the numbers which are occuring behind the scenes of a problem.
2. Ensure you can describe the process you are trying to enact in words.
3. start from the smallest possible component build the functioning solution from functioning blocks.

This should minimise your mistakes, and make it as easy as possible to fix them when they occur.  

## FAQs

None at present, the course has not yet been written, let alone trialled.
